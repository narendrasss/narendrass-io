---
title: The Hard Parts
---

# The Hard Parts

## Principles of Javascript

### Global Execution Context

What happens when javascript runs the following code?

```javascript
const num = 3;
function multiplyBy2(inputNumber) {
    const result = inputNumber * 2;
    return result;
}
const name = "Will";
```

The variables `num` and `name` are stored in global memory. The function `multiplyBy2` is also stored globally, but its contents are skipped because the function is never called.

As the code is run we create a *global execution context*.

The thread that runs javascript is *single-threaded*, that is it only ever runs one thing at a time.

### Local Execution Context

When a function is called, a *local execution context* is created.

```javascript
function multiplyBy2(inputNumber) {
    const result = inputNumber * 2;
    return result;
}
const output = multiplyBy2(4);
```

In the local execution context there exists a *local thread* and *local memory*. The local thread runs all the code within the function block line by line. This execution blocks the global thread from running.

In global memory, `output` is saved as `undefined` until the `multiplyBy2` function finishes executing. Then, `output` is updated to the returned result. Steps:

1. `output` is saved as `undefined` in global memory.
2. In local memory, the parameter `inputNumber` is updated to `4`.
3. The constant `result` is saved into local memory as `4 * 2 = 8`.
4. All local memory is deleted except for `result`.
5. `result` is returned and saved into `output`.

### Call Stack

The call stack is a way for the javascript runtime to know "where" it is in the program. The global execution context is the always on the bottom of this stack. Any additional execution contexts are added to the top of the stack whenever it is created.

## Functional Programming

### Pure Functions

Pure functions are functions that have no **side effects**. This means that the function does not change any other part of the program other than what it is meant to do.

:::tip Note
If a global variable is passed onto a function as a parameter, it is passed by *reference*. This means that if the parameter is changed, then the global variable is changed as well.
:::

### High Order Functions

A high order function is a function that abstracts not only the type of data that it might receive, but also a part of the functionality. In other words, a function that either takes in or returns a function.

This is possible in javascript because functions are treated as **objects**. They operate and can be treated like any other object.

The built-in `map` function is an example of a higher-order function:

```javascript
function map(array, callback) {
    let result = [];
    for (let i = 0; i < array.length; i++) {
        result.push(callback(array[i]));
    }
    return result;
}
```

## Closure

When a function finishes executing, its local memory is deleted. However it is possible for functions to hold on to live data between executions.

The key principle here is that *where* the functions are defined determines *what variables* the function has access to during execution. For example:

```javascript
function outer() {
    let counter = 0;
    return function() {
        counter++;
        console.log(counter);
    }
}
const func = outer();
```

Notice how the returned function does things with the `counter` variable but the `counter` variable itself was never returned. This means that the `counter` variable will be the **same** for all executions of `func`. As a result multiple executions of `func` would show the following:

```javascript
func() // 1
func() // 2
func() // 3
```

The reason this works is because when a function is returned, its *lexical scope* is returned along with it. When the function is run and there is a variable, the javascript engine first looks in the local memory for the variable, then its lexical scope, then the global memory.

If we produce another function by calling `outer` again, say `func2`, then `func2` will have a different lexical scope than `func`. That is it will "restart" the counter variable rather than continuing it from the original calls to `func`.

```javascript
const func = outer();
func() // prints 1
func() // prints 2

const func2 = outer();
func2() // prints 1
```

## Asynchronous Javascript

The fact that javascript's thread is single-threaded suggests that asynchrony is not possible. However asynchronous code is crucial for web development as often we would need to wait for data before calling our functions.

### Browser API

Consider the following code.

```javascript
function printHello() { console.log('Hello'); }

setTimeout(printHello, 0);
console.log('Me first!');
```

What prints first, `me first!` or `hello`? The javascript engine first allocates memory for the definition of `printHello` in the global namespace. But then what exactly happens when `setTimeout` is called?

One of the aspects of the browser API is a background timer. The `setTimeout` function utilizes this timer, using it to determine when `printHello` should be called. In this particular case, `setTimeout` tells the browser to set up a timer for `0ms`, then once it's complete, call `printHello`. As a result, `Me first!` would print before `Hello`.

### Callback Queue

If we add some function that blocks the single javascript thread for a second like so:

```javascript
function printHello() { console.log('Hello'); }

function block1Sec() { /* blocks the thread for 1 sec */ }

setTimeout(printHello, 0);
block1Sec();
console.log('Me first!');
```

Now what gets printed first? The `setTimeout` function does the exact same thing as before, except this time the timer completes *during* the execution of `block1Sec()`.

Whenever a callback is *queued*, it gets added to the **callback queue**. The callback queue works such that it only runs whatever is in front of the queue whenever *all* functions complete, including global. In other words it only adds the function to the call stack whenever the call stack is empty.

Thus in this case `Hello` would always print last as the callback queue waits until all code, that is `block1Sec()` and `console.log`, to complete before it runs `printHello`.

### XMLHttpRequest

Often we would like to receive some form of data from a server somewhere. This is done through `XMLHttpRequest` from the browser API. If we want to receive some data, we pass the `GET` method in the request:

```javascript
const req = new XMLHttpRequest();
req.open("GET", "http://www.example.org/example.txt");
req.send();
```

If we add an *event listener* to the `XMLHttpRequest`, we can pass a callback function that would run when this request completes:

```javascript
function logResponse() {
    console.log(this.responseText);
}
req.addEventListener("load", logResponse);
```

Libraries like `jQuery` wraps up this logic in a simple `get` function like so:

```javascript
function logResponse(data) {
    console.log(data);
}
$.get("http://www.example.org/example.txt", logResponse);
```

## Object-Oriented Javascript

Object oriented programming (OOP) is a programming paradigm used to structure code. It is essentially a way such that all functionality relevant to *some data* is *immediately available* when we are dealing with that exact data.

For example, say we have some users with scores and we wish to have the ability to increase the score for a particular user. We can store this data in an **object**:

```javascript
const user1 = {
    name: "Will",
    score: 3,
    increment: function() {
        user1.score++;
    }
};

user1.increment(); // user1.score = 4
```

### Declaring Objects

One method we can use to declare objects is by first creating an empty object then using **dot notation**:

```javascript
let user2 = {};

user2.name = "Tim";
user2.score = 6;
user2.increment = function() {
    user2.score++;
};
```

We can also use the built-in function `Object.create`:

```javascript
let user3 = Object.create(null);
user3.name = "Eva";
// rest of the code like before
```

This is however quite inconvenient if we wish to do this for many more users. We can automate this by creating a function that produces an object:

```javascript
function userCreator(name, score) {
    let newUser = {};
    newUser.name = name;
    newUser.score = score;
    newUser.increment = function() {
        newUser.score++;
    };
    return newUser;
}

let user1 = userCreator("Will", 3);
let user2 = userCreator("Tim", 5);
```
