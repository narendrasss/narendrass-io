{"remainingRequest":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m03.md?vue&type=template&id=7a2f0a27&","dependencies":[{"path":"/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m03.md","mtime":1539927460087},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"graphs\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#graphs\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Graphs\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"definitions\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#definitions\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Definitions\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A graph \"),\n        _c(\"code\", [_vm._v(\"G\")]),\n        _vm._v(\" is a collection of vertices \"),\n        _c(\"code\", [_vm._v(\"V\")]),\n        _vm._v(\" and edges \"),\n        _c(\"code\", [_vm._v(\"E\")]),\n        _vm._v(\". An edge \"),\n        _c(\"code\", [_vm._v(\"E\")]),\n        _vm._v(\" is defined as a subset containing two vertices, e.g. \"),\n        _c(\"code\", [_vm._v(\"e = {u,v}\")]),\n        _vm._v(\" means there is an edge between vertices \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\" and \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A \"),\n        _c(\"strong\", [_vm._v(\"directed\")]),\n        _vm._v(\n          \" graph is a graph where each edge is order-dependent. That is, \"\n        ),\n        _c(\"code\", [_vm._v(\"e = {u,v}\")]),\n        _vm._v(\" means there is an edge from \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\" to \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\" but not necessarily an edge from \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\" back to \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A graph is \"),\n        _c(\"strong\", [_vm._v(\"connected\")]),\n        _vm._v(\" if, for every pair of vertices \"),\n        _c(\"code\", [_vm._v(\"(u,v)\")]),\n        _vm._v(\", there is a path from \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\" to \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\". If a directed graph has this property it is said to be \"),\n        _c(\"em\", [_vm._v(\"strongly\")]),\n        _vm._v(\" connected.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A strongly connected \"),\n        _c(\"em\", [_vm._v(\"component\")]),\n        _vm._v(\" of a graph is a subgraph of \"),\n        _c(\"code\", [_vm._v(\"G\")]),\n        _vm._v(\" that is strongly connected.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A directed graph is said to be \"),\n        _c(\"strong\", [_vm._v(\"weakly\")]),\n        _vm._v(\n          \" connected if the removal of the directed edges for undirected edges makes the graph connected. Directed graphs can be \"\n        ),\n        _c(\"em\", [_vm._v(\"both\")]),\n        _vm._v(\" weakly and strongly connected.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A \"),\n        _c(\"strong\", [_vm._v(\"simple\")]),\n        _vm._v(\n          \" graph is an undirected, unweighted graph with no multiple edges (no exact repeats of the same edge) and no self-loops.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A \"),\n        _c(\"strong\", [_vm._v(\"cycle\")]),\n        _vm._v(\" in a graph is a collection of connected vertices \"),\n        _c(\"code\", [_vm._v(\"v1, v2, v3, ... vk\")]),\n        _vm._v(\" where \"),\n        _c(\"code\", [_vm._v(\"vk = v1\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"A \"),\n        _c(\"strong\", [_vm._v(\"directed acyclic graph\")]),\n        _vm._v(\" (DAG) is a directed graph that contains no cycles.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"representation\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#representation\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Representation\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"adjacency-matrix\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#adjacency-matrix\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Adjacency Matrix\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"For a graph with number of vertices \"),\n        _c(\"code\", [_vm._v(\"n\")]),\n        _vm._v(\", an adjacency matrix is an \"),\n        _c(\"code\", [_vm._v(\"n x n\")]),\n        _vm._v(\" table where the entry \"),\n        _c(\"code\", [_vm._v(\"[u][v]\")]),\n        _vm._v(\" is 1 if there is an edge between \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\" and \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\", and 0 otherwise.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"An adjacency matrix has the following running times for typical graph operations (assuming number of vertices \"\n        ),\n        _c(\"code\", [_vm._v(\"n\")]),\n        _vm._v(\" and number of edges \"),\n        _c(\"code\", [_vm._v(\"m\")]),\n        _vm._v(\"):\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"table\", [\n        _c(\"thead\", [\n          _c(\"tr\", [\n            _c(\"th\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Operation\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"th\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"Running time\")\n            ])\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tbody\", [\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Storage\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n\"),\n              _c(\"sup\", [_vm._v(\"2\")]),\n              _vm._v(\")\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Add vertex\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n\"),\n              _c(\"sup\", [_vm._v(\"2\")]),\n              _vm._v(\")\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Add edge\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(1)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Remove vertex\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n\"),\n              _c(\"sup\", [_vm._v(\"2\")]),\n              _vm._v(\")\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Remove edge\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(1)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Adjacency of \"),\n              _c(\"code\", [_vm._v(\"u\")]),\n              _vm._v(\" and \"),\n              _c(\"code\", [_vm._v(\"v\")])\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(1)\")\n            ])\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"adjacency-list\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#adjacency-list\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Adjacency List\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"An adjacency list is a list of length \"),\n        _c(\"code\", [_vm._v(\"n\")]),\n        _vm._v(\" where each node corresponds to a vertex. The node \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\" contains a list of \"),\n        _c(\"code\", [_vm._v(\"u\")]),\n        _vm._v(\"'s neighbours.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Running time for typical operations (same assumptions as above):\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"table\", [\n        _c(\"thead\", [\n          _c(\"tr\", [\n            _c(\"th\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Operation\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"th\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"Running time\")\n            ])\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tbody\", [\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Storage\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n + m)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Add vertex\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(1)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Add edge\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(1)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Remove vertex\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(m)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Remove edge\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n)\")\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"tr\", [\n            _c(\"td\", { staticStyle: { \"text-align\": \"left\" } }, [\n              _vm._v(\"Adjacency of \"),\n              _c(\"code\", [_vm._v(\"u\")]),\n              _vm._v(\" and \"),\n              _c(\"code\", [_vm._v(\"v\")])\n            ]),\n            _vm._v(\" \"),\n            _c(\"td\", { staticStyle: { \"text-align\": \"center\" } }, [\n              _vm._v(\"O(n)\")\n            ])\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"bfs\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#bfs\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" BFS\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Breadth-first search (BFS) is one of two common graph traversal algorithms. It traverses the graph layer by layer, exploring all the neighbors of the vertex before moving forward.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function BFS {\\n    Let s be the starting vertex\\n    Initialize Q as an empty queue\\n    Add s to Q\\n    while Q is not empty:\\n        v = first item in Q\\n        visit(v)\\n        for all neighbours w of v:\\n            if w is not visited\\n                add w to Q\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"7\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"8\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"9\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"10\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"11\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Where \"),\n        _c(\"code\", [_vm._v(\"visit()\")]),\n        _vm._v(\" is some operation to be done on the vertex.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"running-time\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#running-time\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Running Time\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"In the worst case every vertex and every edge will be explored, so the running time is \"\n        ),\n        _c(\"code\", [_vm._v(\"O(n + m)\")]),\n        _vm._v(\", assuming the \"),\n        _c(\"code\", [_vm._v(\"visit()\")]),\n        _vm._v(\" operation is in \"),\n        _c(\"code\", [_vm._v(\"O(1)\")]),\n        _vm._v(\" time.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"spanning-trees\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#spanning-trees\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Spanning Trees\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"BFS produces quite natural spanning trees. For example, given the following graph:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: { src: require(\"./assets/bfs-graph.png\"), alt: \"BFS Graph\" }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"BFS would produce the following spanning tree (assuming the algorithm visits the vertices from left to right):\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: require(\"./assets/bfs-graph-tree.png\"),\n            alt: \"BFS Spanning Tree\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"dfs\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#dfs\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" DFS\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Depth-first search (DFS) is the other commonly used graph traversal algorithm. Unlike BFS, DFS recursively searches the first neighbour of a vertex until it reaches a dead-end. Then it backtracks and searches its other neighbours.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function DFS(v) {\\n    visit(v)\\n    for all neighbours w of v\\n        if w is not visited\\n            DFS(w)\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Where \"),\n        _c(\"code\", [_vm._v(\"visit()\")]),\n        _vm._v(\" is some operation on the vertex and \"),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\" is an arbitrary starting vertex to begin the traversal.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"running-time-2\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#running-time-2\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Running Time\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"For the same reason as BFS, the running time of DFS is in \"),\n        _c(\"code\", [_vm._v(\"O(n + m)\")]),\n        _vm._v(\", provided the \"),\n        _c(\"code\", [_vm._v(\"visit()\")]),\n        _vm._v(\" operation is in \"),\n        _c(\"code\", [_vm._v(\"O(1)\")]),\n        _vm._v(\" time.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"spanning-trees-2\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#spanning-trees-2\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Spanning Trees\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"The spanning tree of DFS does not exactly match to the original setup of the graph because of its depth-first nature. For the following graph:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: { src: require(\"./assets/dfs-graph.png\"), alt: \"DFS Graph\" }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"The DFS algorithm would produce the following spanning tree:\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: require(\"./assets/dfs-graph-tree.png\"),\n            alt: \"DFS Spanning Tree\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Notice how this differs from BFS, where BFS will produce the following tree:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: { src: require(\"./assets/bfs-tree-2.png\"), alt: \"BFS Tree 2\" }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"dijkstra-s-algorithm\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#dijkstra-s-algorithm\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Dijkstra's Algorithm\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Dijkstra's algorithm is an algorithm to determine the shortest path between two vertices in a weighted graph.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"Given a starting node \"),\n        _c(\"code\", [_vm._v(\"s\")]),\n        _vm._v(\", dijkstra's algorithm produces a \"),\n        _c(\"em\", [_vm._v(\"shortest-path tree\")]),\n        _vm._v(\" that shows the shortest path from \"),\n        _c(\"code\", [_vm._v(\"s\")]),\n        _vm._v(\" to every other node in the graph.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"the-algorithm\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#the-algorithm\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" The Algorithm\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"The algorithm follows the following steps:\")]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [_vm._v(\"Mark all nodes as unvisited.\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"Assign every node in \"),\n          _c(\"code\", [_vm._v(\"G\")]),\n          _vm._v(\" a \"),\n          _c(\"em\", [_vm._v(\"distance value\")]),\n          _vm._v(\n            \" - 0 for the starting node, and infinity for all other nodes. Let the starting node \"\n          ),\n          _c(\"code\", [_vm._v(\"s\")]),\n          _vm._v(\" be the current node \"),\n          _c(\"code\", [_vm._v(\"v\")]),\n          _vm._v(\".\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"For all neighbours \"),\n          _c(\"code\", [_vm._v(\"w\")]),\n          _vm._v(\" of \"),\n          _c(\"code\", [_vm._v(\"v\")]),\n          _vm._v(\", calculate the cummulative distance from \"),\n          _c(\"code\", [_vm._v(\"v\")]),\n          _vm._v(\" to \"),\n          _c(\"code\", [_vm._v(\"w\")]),\n          _vm._v(\". If this calculated distance is smaller than \"),\n          _c(\"code\", [_vm._v(\"w\")]),\n          _vm._v(\"'s distance value, update \"),\n          _c(\"code\", [_vm._v(\"w\")]),\n          _vm._v(\"'s distance value.\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"Mark \"),\n          _c(\"code\", [_vm._v(\"v\")]),\n          _vm._v(\n            \" as visited and continue traversal to the node with the smallest distance value.\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"running-time-3\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#running-time-3\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Running Time\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"The algorithm runs in \"),\n        _c(\"code\", [_vm._v(\"O(m + nlgn)\")]),\n        _vm._v(\", where \"),\n        _c(\"code\", [_vm._v(\"m\")]),\n        _vm._v(\" is the number of edges in \"),\n        _c(\"code\", [_vm._v(\"G\")]),\n        _vm._v(\" and \"),\n        _c(\"code\", [_vm._v(\"n\")]),\n        _vm._v(\n          \" the number of vertices, assuming the algorithm is implemented with a min-priority queue.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"diameter-problem\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#diameter-problem\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Diameter Problem\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"Consider two more terms for graphs:\")]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"Articulation point: A vertex whose removal increases the number of connected components in the graph (i.e. removing this vertex disconnects the graph).\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"Diameter: The \"),\n          _c(\"em\", [_vm._v(\"diameter\")]),\n          _vm._v(\n            \" is the maximum shortest path (number of edges) between any two nodes \"\n          ),\n          _c(\"code\", [_vm._v(\"u\")]),\n          _vm._v(\" and \"),\n          _c(\"code\", [_vm._v(\"v\")]),\n          _vm._v(\".\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Design an algorithm to determine the diameter of an undirected, unweighted, \"\n        ),\n        _c(\"strong\", [_vm._v(\"connected\")]),\n        _vm._v(\" graph.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"trivial-instances\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#trivial-instances\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Trivial Instances\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"There are three trivial instances for this diameter algorithm:\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [\n          _vm._v(\n            \"The empty graph - if a graph is empty, then its diameter would be 0.\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"Graph with one node - a graph with one node would have no edges and thus the diameter would also be 0.\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"Graph with \"),\n          _c(\"em\", [_vm._v(\"two\")]),\n          _vm._v(\n            \" nodes - a graph with two nodes has only one edge connecting the two nodes. This one edge is the only shortest path, and thus its diameter would be 1.\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"small-instance\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#small-instance\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Small Instance\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"The smallest possible non-trivial instance for this problem is a graph with three nodes like follows:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [_vm._v(\"A -- B -- C\\n\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\"There are three pairs of nodes here, \"),\n        _c(\"code\", [_vm._v(\"(A,B),(A,C),(B,C)\")]),\n        _vm._v(\", with the shortest path lengths of \"),\n        _c(\"code\", [_vm._v(\"{1,2,1}\")]),\n        _vm._v(\n          \" respectively. The maximum shortest path is 2, so the graph's diameter is 2.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"brute-force\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#brute-force\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Brute Force\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"We can generate all solutions to this problem by checking the shortest path between all possible combinations of vertices:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function generateSolutions(G) {\\n    S = empty solution set\\n    for index i from 0 to n\\n        for index j from i+1 to n\\n            add (v_i, v_j) to S\\n    return S\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"7\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"We can then use BFS to determine the length of the shortest path between \"\n        ),\n        _c(\"code\", [_vm._v(\"v_i\")]),\n        _vm._v(\" and \"),\n        _c(\"code\", [_vm._v(\"v_j\")]),\n        _vm._v(\n          \". We have to do this for every pair of vertices that is generated by the brute force algorithm.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"run-time\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#run-time\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Run Time\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"The run time of the brute force algorithm is in \"),\n        _c(\"code\", [_vm._v(\"O(n^2)\")]),\n        _vm._v(\" as there are two nested for loops. A BFS requires \"),\n        _c(\"code\", [_vm._v(\"O(n + m)\")]),\n        _vm._v(\n          \" in the worst case, so the run time of the entire algorithm combined is in \"\n        ),\n        _c(\"code\", [_vm._v(\"O(n^2(n+m))\")]),\n        _vm._v(\", which is in \"),\n        _c(\"code\", [_vm._v(\"O(n^3)\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"optimization\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#optimization\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Optimization\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Note that BFS actually returns the shortest path from a vertex \"\n        ),\n        _c(\"code\", [_vm._v(\"v\")]),\n        _vm._v(\" to \"),\n        _c(\"em\", [_vm._v(\"all other nodes\")]),\n        _vm._v(\n          \". As a result we simply need to run BFS on every single vertex. This significantly improves the running time to \"\n        ),\n        _c(\"code\", [_vm._v(\"O(n(n+m))\")]),\n        _vm._v(\" which is in \"),\n        _c(\"code\", [_vm._v(\"O(n^2)\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"feed-forward-loops\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#feed-forward-loops\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Feed Forward Loops\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Assignment 2 touches on the problem of feed forward loops (FFLs). An FFL is a group of three distinct nodes \"\n        ),\n        _c(\"code\", [_vm._v(\"a,b,c\")]),\n        _vm._v(\" such that there are directed edges \"),\n        _c(\"code\", [_vm._v(\"(a,b),(a,c),(b,c)\")]),\n        _vm._v(\" but not the directed edges \"),\n        _c(\"code\", [_vm._v(\"(b,a),(c,a),(c,b)\")]),\n        _vm._v(\" and no self loops.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"The problem of finding all FFLs in a directed graph \"),\n        _c(\"code\", [_vm._v(\"G\")]),\n        _vm._v(\" is called the FFL detection problem.\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"solution\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#solution\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Solution\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"A simple brute force approach is to generate all possible combinations of vertices and then checking if these groups are FFLs or not.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"The algorithm to generate all solutions:\")]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function genSolutions(G) {\\n    S = empty set of solutions\\n    for i from 1 to n\\n        for j from 1 to n\\n            for k from 1 to n\\n                if (v_i, v_j, v_k) are distinct\\n                    add (v_i, v_j, v_k) to S\\n    return S\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"7\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"8\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"9\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"And the algorithm to check if they are an FFL is a simple if-else statement:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function checkValid(a, b, c) {\\n    if (\\n        (a,b) & (a,c) & (b,c)\\n        & !(b,a) & !(c,a) & !(c,b)\\n        & no self loops\\n    ) return true\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"7\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Note that in the worst case all possible combinations of 3 vertices are FFLs. As a result, the maximum number of FFLs in a given graph \"\n        ),\n        _c(\"code\", [_vm._v(\"G\")]),\n        _vm._v(\" is in \"),\n        _c(\"code\", [_vm._v(\"O(n^3)\")]),\n        _vm._v(\".\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"kidney-exchange-problem\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#kidney-exchange-problem\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Kidney Exchange Problem\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"The kidney exchange problem (KEP) is a problem that involves ideas from both graphs and SMP.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"KEP involves an initial matching of donors and patients. Each patient has a particular preference list; the initial matching may not be the best matching with respect to this preference list.\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"The \"),\n        _c(\"strong\", [_vm._v(\"goal\")]),\n        _vm._v(\" of KEP is to find a better alternative matching. We use a \"),\n        _c(\"em\", [_vm._v(\"best-preference\")]),\n        _vm._v(\n          \" graph to aid in finding this better matching. Some definitions:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"A \"),\n          _c(\"strong\", [_vm._v(\"best-preference\")]),\n          _vm._v(\" graph \"),\n          _c(\"code\", [_vm._v(\"G_I\")]),\n          _vm._v(\" is as follows: a pairing \"),\n          _c(\"code\", [_vm._v(\"(d,p)\")]),\n          _vm._v(\" is a node. There is a directed edge from \"),\n          _c(\"code\", [_vm._v(\"(d,p)\")]),\n          _vm._v(\" to \"),\n          _c(\"code\", [_vm._v(\"(d',p')\")]),\n          _vm._v(\" if \"),\n          _c(\"code\", [_vm._v(\"d'\")]),\n          _vm._v(\" is the highest ranked donor in \"),\n          _c(\"code\", [_vm._v(\"p\")]),\n          _vm._v(\"'s preference list.\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"A \"),\n          _c(\"strong\", [_vm._v(\"valid\")]),\n          _vm._v(\" solution is any perfect matching.\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"An \"),\n          _c(\"strong\", [_vm._v(\"instability\")]),\n          _vm._v(\n            \" is whenever there is a subset of pairs where a reallocation would make all pairs in this subset strictly better off.\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"solution-2\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#solution-2\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Solution\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"The following algorithm constructs a stable solution for any instance of KEP:\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language- line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"function exchange(I) {\\n    S = empty set of solutions\\n    while n > 0\\n        create the best preference graph G_I for I\\n        find a directed cycle v_1, v_2, v_3, v_k = v_1\\n        v_i = (d_i,p_i) for 1 <= i < k\\n        update instance I as follows:\\n            remove the pairs (d_i,p_i) from M, 1 <= i < k\\n            remove d_i from all patient rankings in R, 1 <= i < k\\n            n = n - k + 1\\n        add the pairs (d_i+1,p_i) to S for 1 <= i < k-1, and add (d_1,p_k-1) to S\\n    return S\\n}\\n\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"4\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"5\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"6\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"7\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"8\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"9\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"10\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"11\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"12\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"13\")]),\n          _c(\"br\")\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}