{"remainingRequest":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m04.md?vue&type=template&id=7a2f7e86&","dependencies":[{"path":"/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m04.md","mtime":1544785788528},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"greedy-algorithms\"><a class=\"header-anchor\" href=\"#greedy-algorithms\" aria-hidden=\"true\">#</a> Greedy Algorithms</h1>\n<p>A greedy algorthim is defined as an algorithm that chooses to maximize efficiency at every iteration. One example is the algorithm to solve the interval scheduling problem.</p>\n<h2 id=\"interval-scheduling\"><a class=\"header-anchor\" href=\"#interval-scheduling\" aria-hidden=\"true\">#</a> Interval Scheduling</h2>\n<p>Say we have some resource and a set of requests <code>{1,2,..,n}</code> where the i<sup>th</sup> request corresponds to an interval of time starting at <code>s(i)</code> and finishing at <code>f(i)</code>.</p>\n<h3 id=\"optimal-solution\"><a class=\"header-anchor\" href=\"#optimal-solution\" aria-hidden=\"true\">#</a> Optimal Solution</h3>\n<p>The optimal solution is achieved by first picking the request <code>i</code> that finish the fastest. This is considered <em>greedy</em> because we maximize the amount of time left to satisfy other requests.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>R = set of all requests, A = empty set\nwhile R is not empty\n    i = request in R with smallest finishing time\n    add i to A\n    delete all requests not compatible with i\nreturn A\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>The picture below shows some initial steps for some given instance of the interval scheduing problem:</p>\n<p><img src=\"./assets/interval-sched-1.png\" alt=\"Interval scheduling steps\"></p>\n<h2 id=\"clustering\"><a class=\"header-anchor\" href=\"#clustering\" aria-hidden=\"true\">#</a> Clustering</h2>\n<p>The algorithm to solve the clustering problem performs in the following steps:</p>\n<ol>\n<li>Sort a list of edges <code>E</code> in decreasing order by similarity.</li>\n<li>Initialize each node as its own category.</li>\n<li>Initialize the category count to <code>|V|</code>.</li>\n<li>While there are more than <code>k</code> categories:\n<ol>\n<li>Remove the highest similarity edge <code>(u,v)</code> from the list.</li>\n<li>If <code>u</code> and <code>v</code> are not in the same category: merge <code>u</code>'s and <code>v</code>'s categories, and reduce the category count by 1.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"questions\"><a class=\"header-anchor\" href=\"#questions\" aria-hidden=\"true\">#</a> Questions</h3>\n<p>Imagine we're looking at a categorization produced by our algorithm in which the inter-category edge with maximum similarity is <code>e</code>.</p>\n<p>Can our greedy algorithm's solution have an intra-category edge with <em>lower</em> weight than <code>e</code>?</p>\n<hr>\n<p>Give a bound on the maximum similarity of an arbitrary solution in terms of any one of its inter-category edge weights.</p>\n<hr>\n<p>Give a bound on the maximum similarity of a solution produced by the greedy algorithm in terms of the weight of any one of the edges it considered in step 4.</p>\n<hr>\n<h3 id=\"proof-of-correctness\"><a class=\"header-anchor\" href=\"#proof-of-correctness\" aria-hidden=\"true\">#</a> Proof of Correctness</h3>\n<p>An <strong>instance</strong> of the clustering problem is defined as:</p>\n<ul>\n<li><code>n</code> photos</li>\n<li><code>k</code> categories</li>\n<li>Similarity scores for every pair of photos</li>\n</ul>\n<p>A <strong>valid solution</strong> <code>S</code> is defined as a partition of photos into <code>k</code> non-empty categories.</p>\n<p>The <strong>goodness</strong> of a solution <code>S</code> is the max similarity <code>sim(u,v)</code>, where <code>(u,v)</code> is an inter-category edge.</p>\n<p>Our goal is to <em>minimize</em> the goodness. Let <code>G</code> be the solution provided by our greedy algorithm.</p>\n<div class=\"tip custom-block\"><p class=\"custom-block-title\">Claim</p>\n<p>The goodness of <code>G</code> is &lt;= the goodness of <code>S</code> for all valid solutions <code>S</code>.</p>\n</div>\n</div>\n",null]}