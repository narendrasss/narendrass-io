{"remainingRequest":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m03.md?vue&type=template&id=7a2f0a27&","dependencies":[{"path":"/Users/Narendras/Documents/Projects/Website/docs/cpsc/320/m03.md","mtime":1539927460087},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/cache-loader/dist/cjs.js","mtime":1539927363321},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/Narendras/Documents/Projects/Website/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"graphs\"><a class=\"header-anchor\" href=\"#graphs\" aria-hidden=\"true\">#</a> Graphs</h1>\n<h2 id=\"definitions\"><a class=\"header-anchor\" href=\"#definitions\" aria-hidden=\"true\">#</a> Definitions</h2>\n<p>A graph <code>G</code> is a collection of vertices <code>V</code> and edges <code>E</code>. An edge <code>E</code> is defined as a subset containing two vertices, e.g. <code>e = {u,v}</code> means there is an edge between vertices <code>u</code> and <code>v</code>.</p>\n<p>A <strong>directed</strong> graph is a graph where each edge is order-dependent. That is, <code>e = {u,v}</code> means there is an edge from <code>u</code> to <code>v</code> but not necessarily an edge from <code>v</code> back to <code>u</code>.</p>\n<p>A graph is <strong>connected</strong> if, for every pair of vertices <code>(u,v)</code>, there is a path from <code>u</code> to <code>v</code>. If a directed graph has this property it is said to be <em>strongly</em> connected.</p>\n<p>A strongly connected <em>component</em> of a graph is a subgraph of <code>G</code> that is strongly connected.</p>\n<p>A directed graph is said to be <strong>weakly</strong> connected if the removal of the directed edges for undirected edges makes the graph connected. Directed graphs can be <em>both</em> weakly and strongly connected.</p>\n<p>A <strong>simple</strong> graph is an undirected, unweighted graph with no multiple edges (no exact repeats of the same edge) and no self-loops.</p>\n<p>A <strong>cycle</strong> in a graph is a collection of connected vertices <code>v1, v2, v3, ... vk</code> where <code>vk = v1</code>.</p>\n<p>A <strong>directed acyclic graph</strong> (DAG) is a directed graph that contains no cycles.</p>\n<h2 id=\"representation\"><a class=\"header-anchor\" href=\"#representation\" aria-hidden=\"true\">#</a> Representation</h2>\n<h3 id=\"adjacency-matrix\"><a class=\"header-anchor\" href=\"#adjacency-matrix\" aria-hidden=\"true\">#</a> Adjacency Matrix</h3>\n<p>For a graph with number of vertices <code>n</code>, an adjacency matrix is an <code>n x n</code> table where the entry <code>[u][v]</code> is 1 if there is an edge between <code>u</code> and <code>v</code>, and 0 otherwise.</p>\n<p>An adjacency matrix has the following running times for typical graph operations (assuming number of vertices <code>n</code> and number of edges <code>m</code>):</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Operation</th>\n<th style=\"text-align:center\">Running time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Storage</td>\n<td style=\"text-align:center\">O(n<sup>2</sup>)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Add vertex</td>\n<td style=\"text-align:center\">O(n<sup>2</sup>)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Add edge</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Remove vertex</td>\n<td style=\"text-align:center\">O(n<sup>2</sup>)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Remove edge</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Adjacency of <code>u</code> and <code>v</code></td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"adjacency-list\"><a class=\"header-anchor\" href=\"#adjacency-list\" aria-hidden=\"true\">#</a> Adjacency List</h3>\n<p>An adjacency list is a list of length <code>n</code> where each node corresponds to a vertex. The node <code>u</code> contains a list of <code>u</code>'s neighbours.</p>\n<p>Running time for typical operations (same assumptions as above):</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Operation</th>\n<th style=\"text-align:center\">Running time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Storage</td>\n<td style=\"text-align:center\">O(n + m)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Add vertex</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Add edge</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Remove vertex</td>\n<td style=\"text-align:center\">O(m)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Remove edge</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Adjacency of <code>u</code> and <code>v</code></td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"bfs\"><a class=\"header-anchor\" href=\"#bfs\" aria-hidden=\"true\">#</a> BFS</h2>\n<p>Breadth-first search (BFS) is one of two common graph traversal algorithms. It traverses the graph layer by layer, exploring all the neighbors of the vertex before moving forward.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function BFS {\n    Let s be the starting vertex\n    Initialize Q as an empty queue\n    Add s to Q\n    while Q is not empty:\n        v = first item in Q\n        visit(v)\n        for all neighbours w of v:\n            if w is not visited\n                add w to Q\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Where <code>visit()</code> is some operation to be done on the vertex.</p>\n<h3 id=\"running-time\"><a class=\"header-anchor\" href=\"#running-time\" aria-hidden=\"true\">#</a> Running Time</h3>\n<p>In the worst case every vertex and every edge will be explored, so the running time is <code>O(n + m)</code>, assuming the <code>visit()</code> operation is in <code>O(1)</code> time.</p>\n<h3 id=\"spanning-trees\"><a class=\"header-anchor\" href=\"#spanning-trees\" aria-hidden=\"true\">#</a> Spanning Trees</h3>\n<p>BFS produces quite natural spanning trees. For example, given the following graph:</p>\n<p><img src=\"./assets/bfs-graph.png\" alt=\"BFS Graph\"></p>\n<p>BFS would produce the following spanning tree (assuming the algorithm visits the vertices from left to right):</p>\n<p><img src=\"./assets/bfs-graph-tree.png\" alt=\"BFS Spanning Tree\"></p>\n<h2 id=\"dfs\"><a class=\"header-anchor\" href=\"#dfs\" aria-hidden=\"true\">#</a> DFS</h2>\n<p>Depth-first search (DFS) is the other commonly used graph traversal algorithm. Unlike BFS, DFS recursively searches the first neighbour of a vertex until it reaches a dead-end. Then it backtracks and searches its other neighbours.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function DFS(v) {\n    visit(v)\n    for all neighbours w of v\n        if w is not visited\n            DFS(w)\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Where <code>visit()</code> is some operation on the vertex and <code>v</code> is an arbitrary starting vertex to begin the traversal.</p>\n<h3 id=\"running-time-2\"><a class=\"header-anchor\" href=\"#running-time-2\" aria-hidden=\"true\">#</a> Running Time</h3>\n<p>For the same reason as BFS, the running time of DFS is in <code>O(n + m)</code>, provided the <code>visit()</code> operation is in <code>O(1)</code> time.</p>\n<h3 id=\"spanning-trees-2\"><a class=\"header-anchor\" href=\"#spanning-trees-2\" aria-hidden=\"true\">#</a> Spanning Trees</h3>\n<p>The spanning tree of DFS does not exactly match to the original setup of the graph because of its depth-first nature. For the following graph:</p>\n<p><img src=\"./assets/dfs-graph.png\" alt=\"DFS Graph\"></p>\n<p>The DFS algorithm would produce the following spanning tree:</p>\n<p><img src=\"./assets/dfs-graph-tree.png\" alt=\"DFS Spanning Tree\"></p>\n<p>Notice how this differs from BFS, where BFS will produce the following tree:</p>\n<p><img src=\"./assets/bfs-tree-2.png\" alt=\"BFS Tree 2\"></p>\n<h2 id=\"dijkstra-s-algorithm\"><a class=\"header-anchor\" href=\"#dijkstra-s-algorithm\" aria-hidden=\"true\">#</a> Dijkstra's Algorithm</h2>\n<p>Dijkstra's algorithm is an algorithm to determine the shortest path between two vertices in a weighted graph.</p>\n<p>Given a starting node <code>s</code>, dijkstra's algorithm produces a <em>shortest-path tree</em> that shows the shortest path from <code>s</code> to every other node in the graph.</p>\n<h3 id=\"the-algorithm\"><a class=\"header-anchor\" href=\"#the-algorithm\" aria-hidden=\"true\">#</a> The Algorithm</h3>\n<p>The algorithm follows the following steps:</p>\n<ol>\n<li>Mark all nodes as unvisited.</li>\n<li>Assign every node in <code>G</code> a <em>distance value</em> - 0 for the starting node, and infinity for all other nodes. Let the starting node <code>s</code> be the current node <code>v</code>.</li>\n<li>For all neighbours <code>w</code> of <code>v</code>, calculate the cummulative distance from <code>v</code> to <code>w</code>. If this calculated distance is smaller than <code>w</code>'s distance value, update <code>w</code>'s distance value.</li>\n<li>Mark <code>v</code> as visited and continue traversal to the node with the smallest distance value.</li>\n</ol>\n<h3 id=\"running-time-3\"><a class=\"header-anchor\" href=\"#running-time-3\" aria-hidden=\"true\">#</a> Running Time</h3>\n<p>The algorithm runs in <code>O(m + nlgn)</code>, where <code>m</code> is the number of edges in <code>G</code> and <code>n</code> the number of vertices, assuming the algorithm is implemented with a min-priority queue.</p>\n<h2 id=\"diameter-problem\"><a class=\"header-anchor\" href=\"#diameter-problem\" aria-hidden=\"true\">#</a> Diameter Problem</h2>\n<p>Consider two more terms for graphs:</p>\n<ul>\n<li>Articulation point: A vertex whose removal increases the number of connected components in the graph (i.e. removing this vertex disconnects the graph).</li>\n<li>Diameter: The <em>diameter</em> is the maximum shortest path (number of edges) between any two nodes <code>u</code> and <code>v</code>.</li>\n</ul>\n<p>Design an algorithm to determine the diameter of an undirected, unweighted, <strong>connected</strong> graph.</p>\n<h3 id=\"trivial-instances\"><a class=\"header-anchor\" href=\"#trivial-instances\" aria-hidden=\"true\">#</a> Trivial Instances</h3>\n<p>There are three trivial instances for this diameter algorithm:</p>\n<ol>\n<li>The empty graph - if a graph is empty, then its diameter would be 0.</li>\n<li>Graph with one node - a graph with one node would have no edges and thus the diameter would also be 0.</li>\n<li>Graph with <em>two</em> nodes - a graph with two nodes has only one edge connecting the two nodes. This one edge is the only shortest path, and thus its diameter would be 1.</li>\n</ol>\n<h3 id=\"small-instance\"><a class=\"header-anchor\" href=\"#small-instance\" aria-hidden=\"true\">#</a> Small Instance</h3>\n<p>The smallest possible non-trivial instance for this problem is a graph with three nodes like follows:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>A -- B -- C\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>There are three pairs of nodes here, <code>(A,B),(A,C),(B,C)</code>, with the shortest path lengths of <code>{1,2,1}</code> respectively. The maximum shortest path is 2, so the graph's diameter is 2.</p>\n<h3 id=\"brute-force\"><a class=\"header-anchor\" href=\"#brute-force\" aria-hidden=\"true\">#</a> Brute Force</h3>\n<p>We can generate all solutions to this problem by checking the shortest path between all possible combinations of vertices:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function generateSolutions(G) {\n    S = empty solution set\n    for index i from 0 to n\n        for index j from i+1 to n\n            add (v_i, v_j) to S\n    return S\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>We can then use BFS to determine the length of the shortest path between <code>v_i</code> and <code>v_j</code>. We have to do this for every pair of vertices that is generated by the brute force algorithm.</p>\n<h3 id=\"run-time\"><a class=\"header-anchor\" href=\"#run-time\" aria-hidden=\"true\">#</a> Run Time</h3>\n<p>The run time of the brute force algorithm is in <code>O(n^2)</code> as there are two nested for loops. A BFS requires <code>O(n + m)</code> in the worst case, so the run time of the entire algorithm combined is in <code>O(n^2(n+m))</code>, which is in <code>O(n^3)</code>.</p>\n<h3 id=\"optimization\"><a class=\"header-anchor\" href=\"#optimization\" aria-hidden=\"true\">#</a> Optimization</h3>\n<p>Note that BFS actually returns the shortest path from a vertex <code>v</code> to <em>all other nodes</em>. As a result we simply need to run BFS on every single vertex. This significantly improves the running time to <code>O(n(n+m))</code> which is in <code>O(n^2)</code>.</p>\n<h2 id=\"feed-forward-loops\"><a class=\"header-anchor\" href=\"#feed-forward-loops\" aria-hidden=\"true\">#</a> Feed Forward Loops</h2>\n<p>Assignment 2 touches on the problem of feed forward loops (FFLs). An FFL is a group of three distinct nodes <code>a,b,c</code> such that there are directed edges <code>(a,b),(a,c),(b,c)</code> but not the directed edges <code>(b,a),(c,a),(c,b)</code> and no self loops.</p>\n<p>The problem of finding all FFLs in a directed graph <code>G</code> is called the FFL detection problem.</p>\n<h3 id=\"solution\"><a class=\"header-anchor\" href=\"#solution\" aria-hidden=\"true\">#</a> Solution</h3>\n<p>A simple brute force approach is to generate all possible combinations of vertices and then checking if these groups are FFLs or not.</p>\n<p>The algorithm to generate all solutions:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function genSolutions(G) {\n    S = empty set of solutions\n    for i from 1 to n\n        for j from 1 to n\n            for k from 1 to n\n                if (v_i, v_j, v_k) are distinct\n                    add (v_i, v_j, v_k) to S\n    return S\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>And the algorithm to check if they are an FFL is a simple if-else statement:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function checkValid(a, b, c) {\n    if (\n        (a,b) &amp; (a,c) &amp; (b,c)\n        &amp; !(b,a) &amp; !(c,a) &amp; !(c,b)\n        &amp; no self loops\n    ) return true\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Note that in the worst case all possible combinations of 3 vertices are FFLs. As a result, the maximum number of FFLs in a given graph <code>G</code> is in <code>O(n^3)</code>.</p>\n<h2 id=\"kidney-exchange-problem\"><a class=\"header-anchor\" href=\"#kidney-exchange-problem\" aria-hidden=\"true\">#</a> Kidney Exchange Problem</h2>\n<p>The kidney exchange problem (KEP) is a problem that involves ideas from both graphs and SMP.</p>\n<p>KEP involves an initial matching of donors and patients. Each patient has a particular preference list; the initial matching may not be the best matching with respect to this preference list.</p>\n<p>The <strong>goal</strong> of KEP is to find a better alternative matching. We use a <em>best-preference</em> graph to aid in finding this better matching. Some definitions:</p>\n<ul>\n<li>A <strong>best-preference</strong> graph <code>G_I</code> is as follows: a pairing <code>(d,p)</code> is a node. There is a directed edge from <code>(d,p)</code> to <code>(d',p')</code> if <code>d'</code> is the highest ranked donor in <code>p</code>'s preference list.</li>\n<li>A <strong>valid</strong> solution is any perfect matching.</li>\n<li>An <strong>instability</strong> is whenever there is a subset of pairs where a reallocation would make all pairs in this subset strictly better off.</li>\n</ul>\n<h3 id=\"solution-2\"><a class=\"header-anchor\" href=\"#solution-2\" aria-hidden=\"true\">#</a> Solution</h3>\n<p>The following algorithm constructs a stable solution for any instance of KEP:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function exchange(I) {\n    S = empty set of solutions\n    while n &gt; 0\n        create the best preference graph G_I for I\n        find a directed cycle v_1, v_2, v_3, v_k = v_1\n        v_i = (d_i,p_i) for 1 &lt;= i &lt; k\n        update instance I as follows:\n            remove the pairs (d_i,p_i) from M, 1 &lt;= i &lt; k\n            remove d_i from all patient rankings in R, 1 &lt;= i &lt; k\n            n = n - k + 1\n        add the pairs (d_i+1,p_i) to S for 1 &lt;= i &lt; k-1, and add (d_1,p_k-1) to S\n    return S\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}